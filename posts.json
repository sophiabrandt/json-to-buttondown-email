{"titles":[" Use Environment Variables With VuePress 2"," Notes on ‚ÄúBuilding a Pragmatic Unit Test Suite‚Äù"," My First T3 App"," Write Better in Neovim With Languagetool"],"content":"Hello üëã! Thanks for subscribing.\n\n\nHere are my latest articles:\n\n## [Use Environment Variables With VuePress 2](https://www.rockyourcode.com/use-environment-variables-with-vuepress-2/)\n\nPublished on: 2022-11-07\n\ntags: Vue.js, JavaScript\n\n\nFor `$DAYJOB` I had to build a new feature for our internal **[VuePress 2][vuep]** documentation.\n\nI needed to fetch data from an API that needs an API token. That's why I wanted to use [environment variables][env] to store the token, both locally as well in our [CI pipeline](https://www.redhat.com/en/topics/devops/what-cicd-pipeline).\n\nSurprisingly this was hard to figure out. It didn't help that I've never worked with [Vue.js](https://vuejs.org) or VuePress. The documentation was of limited help.\n\nFor example, I stumbled upon the famous error when trying to use `process.env` in a Vue component:\n\n```bash\nprocess is not defined\n```\n\nI'll show you how you can use environment variables in VuePress in the following article.\n\n## Goal\n\nWe want to be able to use a local file called `.env` (or something similar like `.env.local`) to store sensitive data.\n\nExample content of the `.env` file:\n\n```env\nGOOGLE_API_TOKEN='abcdefghi12345'\n```\n\nWe want to be able to use this token in the [JavaScript part of Vue](https://vuejs.org/guide/introduction.html#single-file-components).\n\nExample:\n\n```vue\n<script>\nimport fetch from 'cross-fetch'\n\nasync function fetchData() {\n  const response = await fetch('some-url', {\n    method: 'GET',\n    headers: {\n      // here we need our token üëá\n      Authorization: `Token token=`,\n    },\n  })\n  return response.json()\n}\n</script>\n```\n\n<details>\n    <summary>Note about cross-fetch</summary>\n    <p>I've installed this library to be able to use the fetch API in Node.js during VuePress's generate step.</p>\n    <p>In the generate phase Node.js builds all pages, so we don't have the fetch API (browser-only until Node 18) at our disposal.</p>\n</details>\n\n## Problem\n\nI couldn't find a guide in the [VuePress documentation](https://v2.vuepress.vuejs.org/guide), the [top StackOverflow question](https://stackoverflow.com/questions/53669076/how-do-i-expose-node-environment-variables-via-configurewebpack-to-vuepress-comp) seems outdated, and the [GitHub issue][gh] only got me 90% to the solution.\n\n## Solution\n\nThere is one library we need to install:\n\n```sh\nnpm i dotenv\n```\n\n[`dotenv`](https://www.npmjs.com/package/dotenv) is a popular JavaScript library which allows us to load environment variables from files. Exactly our use case!\n\nNow we need to adjust the configuration for VuePress. You can read more about the [Config file in the docs](https://v2.vuepress.vuejs.org/guide/configuration.html).\n\nAdd `dotenv` to the Vue config file (`config.js`):\n\n```js\n// all other imports, e.g.\n// import { registerComponentsPlugin } from '@vuepress/plugin-register-components';\nimport * as dotenv from 'dotenv'\n\ndotenv.config()\n```\n\nThe above code allows us to read our API token from the environment file. But how can we pass the variable to our frontend Vue component?\n\nYou **cannot** do this:\n\n```vue\n<script>\nconst TOKEN = process.env.GOGGLE_API_TOKEN\n</script>\n```\n\nThe Vue component in VuePress _can_ be a client-side component. The browser can't access `process`, that's Node.js-only.\n\nYou'll see this error:\n\n```bash\nprocess is not defined\n```\n\n[VuePress has a hook to define global constants for the client code][defineh].\n\nAdd the following to your config object in `config.js`:\n\n```js\nexport default defineUserConfig({\n  // previous configuration\n  // dest: 'public',\n  // lang: 'de-DE',\n  define: {\n    __TOKEN__: process.env.GOOGLE_API_TOKEN,\n  },\n})\n```\n\nNow you can do the following in your Vue component:\n\n```vue\n<script>\nimport fetch from 'cross-fetch'\n\nasync function fetchData() {\n  const response = await fetch('some-url', {\n    method: 'GET',\n    headers: {\n      // here we can access the global constant üëá\n      Authorization: `Token token=${__TOKEN__}`,\n    },\n  })\n  return response.json()\n}\n</script>\n```\n\nThe `__TOKEN__` variable will \"magically\" work.\n\n## Summary\n\nHere we have a working solution. Maybe there's a better way.  \nI don't like to use global constants. If you work with the Vue component it's not clear where the variable comes from.\n\nBut that's at least a working solution.\n\n## Links\n\n- [Passing Data to Client Code][defineh]\n- [GitHub: Are environment variables supported? #214][gh]\n\n[vuep]: https://v2.vuepress.vuejs.org/\n[env]: https://www.freecodecamp.org/news/what-are-environment-variables-and-how-can-i-use-them-with-gatsby-and-netlify/\n[gh]: https://github.com/vuejs/vuepress/issues/214\n[defineh]: https://v2.vuepress.vuejs.org/advanced/cookbook/passing-data-to-client-code.html\n\n\n<hr />\n## [Notes on ‚ÄúBuilding a Pragmatic Unit Test Suite‚Äù](https://www.rockyourcode.com/notes-on-building-a-pragmatic-unit-test-suite/)\n\nPublished on: 2022-10-30\n\ntags: Testing\n\n\nHere are some notes on the course ‚ÄúBuilding a Pragmatic Unit Test Suite‚Äù by Vladimir Khorikov.\n\n## Goals and Guidelines\n\nUnit tests help with _confidence_: you know that changes don't break functionality.\n\nNot all unit tests are equal.\n\nCoverage metrics are problematic: you can work around them, for example, by writing assertion-free unit tests.  \nCoverage metrics are a good negative indicator, but 100% test coverage is impractical.\n\nTest are code, and you also have to pay a maintenance cost for your tests.\n\nWhat makes a unit test valuable?\n\n- carefully choose code to test\n- use the most valuable tests only\n\nA good unit test:\n\n- has a high chance of catching a regression error\n- has a low chance of producing a false positive\n- provides fast feedback\n- has low maintenance cost\n\n_Testing trivial code is not worth the cost._\n\nDecouple tests from implementation details as much as possible.\n\nSpend most of the time on testing business logic.\n\n## Styles of Unit Testing\n\n- output-based verification (functional style)\n- state verification\n- collaboration verification (uses _test doubles_)\n\n### Hexagonal Architecture\n\n![hexagonal architecture](https://upload.wikimedia.org/wikipedia/commons/thumb/7/75/Hexagonal_Architecture.svg/768px-Hexagonal_Architecture.svg.png)\n_image from [Wikipedia](https://en.wikipedia.org/wiki/Hexagonal_architecture_(software))\\_\n\n## Implementation Detail\n\nPublic API is the surface area that you can access from outside a class.\n\nWhat are the requirements?\n\n- address an immediate goal of the client code\n- address that goal completely\n\nLook at the client code: if it uses more than 1 operation to achieve a single goal, the class is leaking implementation details.\n\nNote: Neighboring classes might be aware of implementation details.  \nExample: the Root Entity of an _Aggregate_ (Domain Driven Design) might know about implementation details of the Entities.\n\nCommunication inside a hexagon is implementation detail.  \nBetween hexagons a public API of the hexagon exist (contract).\n\n### Styles\n\n- functional style: has no state, easy to maintain, offers the best protection against false positive\n- state verification: should verify through public API, reasonable maintenance cost\n- collaboration verification: within the hexagon lots of false positives; between hexagons more stable\n\n### Black-Box Testing Vs. White-Box Testing\n\n- black-box testing: testing without knowing the internal structure\n- white-box testing: testing the internal structure\n\nAdhere to black-box testing as much as possible.\n\n### Business Requirements\n\nDoes the test verify a business requirement?\n\n* view your code from the end user's perspective\n* verify its observable behavior\n\n## Integration Tests\n\n- test data cleanup: wipe out all data _before_ test execution\n\n## Unit Testing Anti-Patterns\n\n- private methods: if needed expose the hidden abstraction by extracting a new concept\n- expose state getters: test the observable behavior only\n- leaking domain knowledge to tests: use property-paced testing, or verify end result\n- code pollution (introduce additional code just to enable unit testing)\n- overriding methods in classes-dependencies: violates single-repository-principle, instead split functionality into different pieces\n- non-determinism in tests: try to avoid testing async code (separate code into async/sync), use Tasks\n\n## Links\n\n* [Building a Pragmatic Unit Test Suite][pluralsight]\n\n[pluralsight]: https://pluralsight.com/courses/pragmatic-unit-testing\n\n\n<hr />\n## [My First T3 App](https://www.rockyourcode.com/my-first-t3-app/)\n\nPublished on: 2022-10-25\n\ntags: TypeScript\n\n\n[tRPC][trpc] is the hottest new thing in the TypeScript ecosystem: build end-to-end **type-safe** APIs without the overhead of GraphQL.\n\ntRPC is a protocol to expose a function of your backend to your frontend using TypeScript type definitions.  \nNo code generation required. You write both your backend and your frontend with TypeScript and share the types.\n\n\ntRPC is framework-agnostic.\n\n[Create-t3-app][t3] is build on top of tRPC. It offers an opinionated starter template that helps with building a complete web application with [Next.js](https://nextjs.org) and Prisma.\n\nThis blog post chronicles my journey in creating my first T3 app. Let's see how the T3 stack works!\n\n## Create Application\n\n```bash\npnpm dlx create-t3-app@latest\n```\n\nThe command guides you through the installation process and allows you to choose a few options (trpc, prisma, next-auth, tailwind).\n\nI am happy to see that the command also works with [pnpm](https://pnpm.io) out of the box.\n\nThe command bootstraps the application. At the end of the process, there is a hint on what commands to run:\n\n```bash\ncd my-t3-app\npnpm install\npnpm prisma db push\npnpm dev\n```\n\nThe project also offers a `README` file with minimal information to get you started.\n\n## Prisma\n\nMy application should show cat pictures because the internet loves cats.\n\nLet's adjust the Prisma schema:\n\n```diff\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"sqlite\"\n  url      = env(\"DATABASE_URL\")\n}\n\n+model Cat {\n+  id        String   @id @default(cuid())\n+  createdAt DateTime @default(now())\n+  updatedAt DateTime @updatedAt\n+  imageUrl  String\n+}\n```\n\nThis looks like a minimal example for a first application. Run `pnpm exec prisma migrate dev --name add_cat_model`.\n\n## tRPC Router\n\nMy next instinct is to hook up the trpc router. The project comes with an example router in `src/server/router/example.ts`. I'll adjust that to be a cat router.\n\nThe router uses [zod][zod], a schema-validation library, to build a router.\n\nThe example query has an input parameter of the String type.  \nFor my case, I want a random cat picture, so no input is needed. Can I just delete the input parameter and return a random cat?\n\nBefore:\n\n```ts\nimport { createRouter } from './context'\nimport { z } from 'zod'\n\nexport const exampleRouter = createRouter()\n  .query('hello', {\n    input: z\n      .object({\n        text: z.string().nullish(),\n      })\n      .nullish(),\n    resolve({ input }) {\n      return {\n        greeting: `Hello ${input?.text ?? 'world'}`,\n      }\n    },\n  })\n  .query('getAll', {\n    async resolve({ ctx }) {\n      return await ctx.prisma.example.findMany()\n    },\n  })\n```\n\nAfter:\n\n```ts\nimport { createRouter } from './context'\nimport { Cat } from '@prisma/client'\n\nexport const catRouter = createRouter()\n  .query('random', {\n    async resolve({ ctx }) {\n      const randomCats = await ctx.prisma.$queryRaw<Cat[]>`SELECT id, imageUrl\n                                                           FROM Cat\n                                                           ORDER BY RANDOM()\n                                                           LIMIT 1`\n      return randomCats[0]\n    },\n  })\n  .query('getAll', {\n    async resolve({ ctx }) {\n      return await ctx.prisma.cat.findMany()\n    },\n  })\n```\n\nI use a [raw SQL query][queryraw] to retrieve a random cat from the database and add a typing for `Cat[]`.  \nThat's not pretty and does not give me the advantage of using the schema validator, but Prisma doesn't implement [getting a random record](https://github.com/prisma/prisma/issues/5894). So raw SQL it is!\n\nThe raw query returns an array in any case, so we select the first element and return it.\n\n## Seed Script\n\nBefore I try to hook up the frontend, I remember that I don't have any example data in my database.\n\nLuckily, the Prisma documentation can [help me][seed].\n\nAdd a new entry to `package.json`:\n\n```json\n{\n  \"prisma\": {\n    \"seed\": \"ts-node --compiler-options {\\\"module\\\":\\\"CommonJS\\\"} prisma/seed.ts\"\n  }\n}\n```\n\nCreate a new seed script in the `prisma` folder (`prisma/seed.ts`):\n\n```ts\nimport { PrismaClient } from '@prisma/client'\nimport { fetch } from 'next/dist/compiled/@edge-runtime/primitives/fetch'\n\nconst prisma = new PrismaClient()\n\nasync function main() {\n  const requests = Array(10)\n    .fill('https://aws.random.cat/meow')\n    .map((url) => fetch(url))\n\n  Promise.all(requests)\n    // map array of responses into an array of response.json() to read their content\n    .then((responses) => Promise.all(responses.map((r) => r.json())))\n    // insert all responses as imageUrl\n    .then((cats) =>\n      cats.forEach(\n        async (cat) => await prisma.cat.create({ data: { imageUrl: cat.file } })\n      )\n    )\n}\n\nmain()\n  .then(async () => {\n    await prisma.$disconnect()\n  })\n  .catch(async (e) => {\n    console.error(e)\n    await prisma.$disconnect()\n    process.exit(1)\n  })\n```\n\nI fetch ten image URLs from an API that offers random cat images and insert them into the database. Quite ugly, but it works.\n\nIn my terminal, I run type the following command:\n\n```bash\npnpm exec prisma db seed\n```\n\nSuccess!\n\n## Hook Up the Client\n\nFinally, we can try to show this data on the browser.\n\nAfter ripping out the example router and replacing it with my cat router, I check `src/pages/index.tsx`.\n\nIt has some boilerplate which I adjust to my needs:\n\n```tsx\nimport type { NextPage } from 'next'\nimport Head from 'next/head'\nimport Image from 'next/image'\nimport { trpc } from '../utils/trpc'\n\nconst Home: NextPage = () => {\n  const { data: cat } = trpc.useQuery(['cat.random'])\n\n  return (\n    <div style={{ display: 'grid', placeItems: 'center' }}>\n      <Head>\n        <title>T3 Cats</title>\n        <meta name=\"T3 cats\" content=\"Generated by create-t3-app\" />\n        <link rel=\"icon\" href=\"/favicon.ico\" />\n      </Head>\n      <div>\n        <h1 style={{ textAlign: 'center' }}>\n          Create <span>T3</span> App\n        </h1>\n\n        <section>\n          <div>\n            {cat ? (\n              <Image\n                src={cat.imageUrl}\n                alt={`random cat ${cat.id}`}\n                layout={'fixed'}\n                width={300}\n                height={300}\n              />\n            ) : (\n              <p>Loading...</p>\n            )}\n          </div>\n        </section>\n      </div>\n    </div>\n  )\n}\n\nexport default Home\n```\n\nThat was surprisingly easy, especially if you are familiar with Prisma.\n\n## First Impressions\n\nThe starter template does a good job on guiding you through the process.\n\nThe examples are enough to paint a broad picture on how trpc with Next.js works. Familiarity with prisma is assumed.\n\nYou might need to consult the Prisma documentation, trpc is almost self-declaratory, Prisma is not.\n\n## Links\n\n- [tRPC][trpc]\n- [Create T3 App][t3]\n\n[trpc]: https://trpc.io\n[t3]: https://create.t3.gg/\n[zod]: https://github.com/colinhacks/zod\n[queryraw]: https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access\n[seed]: https://www.prisma.io/docs/guides/database/seed-database\n\n\n<hr />\n## [Write Better in Neovim With Languagetool](https://www.rockyourcode.com/write-better-in-neovim-with-languagetool/)\n\nPublished on: 2022-10-02\n\ntags: DevTools, Vim\n\n\n**[LanguageTool][lt]** is a grammar tool and spell checker with an open-source core.\n\nI have used [grammarly](https://www.grammarly.com/) for a while, but the browser extension was crap.  \nA colleague recommended LanguageTool (LT), and I've been a happy user of the browser extension ever since.\n\nLT has superior support for other languages than English.\nIt also features decent suggestions for improving your grammar.\nThe free tier of LT has been a better experience for me than grammarly.\n\nDid you know that you can use LT as a language server for NeoVim and other editors?\n\n## Install ltex-ls\n\nLT has no direct support for the [language server protocol](https://microsoft.github.io/language-server-protocol/), but fear not ‚Äì a clever programmer has included the LT server in his LSP implementation.\n\nThe tool is called **[ltex-ls][ltexls]**, and it's free software.\n\nYou can find the installation instructions on the [ltex-ls website](https://valentjn.github.io/ltex/ltex-ls/installation.html).\n\nFor macOS, you can use [homebrew](https://brew.sh):\n\n```bash\nbrew install ltex-ls\n```\n\nThe command installs the server as `ltex-ls` in your standard homebrew location and thus adds it to your `$PATH`.\n\nIf you manually install the program, make sure to add the binary to your `$PATH`, for example with [`fish_add_path`](https://fishshell.com/docs/current/cmds/fish_add_path.html).\n\n## Integration With nvim-lsp\n\nCheck the [recommended configuration on the nvim-lsp GitHub](https://github.com/neovim/nvim-lspconfig#suggested-configuration) and add the following configuration:\n\n```lua\nrequire('lspconfig')['ltex']({\n  on_attach = on_attach,\n  cmd = { \"ltex-ls\" },\n  filetypes = { \"markdown\", \"text\" },\n  flags = { debounce_text_changes = 300 },\n})\n```\n\nYou should add the server command into the `cmd` section. On macOS, `ltex-ls` worked fine for me.\n\nHere you can see how the tool points out possible errors in my text:\n\n![neovim languagetool example](/languagetool-neovim.png)\n\n## Other Editors\n\nI originally found the instructions for using ltex-lsp on a blog about the [Helix Editor][helix]: [Note talking with Helix, Tp-Note and LanguageTool][getreu].\n\nHere is the the content of `~/.config/helix/languages.toml`:\n\n```toml\n[[language]]\nfile-types = [\"md\", \"txt\"]\nindent = { tab-width = 2, unit = \"  \" }\ninjection-regex = \"md|markdown\"\nlanguage-server = { command = \"ltex-ls\" }\nname = \"markdown\"\nroots = [\".git\"]\nscope = \"source.md\"\n```\n\nIf you use [VS Code](https://code.visualstudio.com/), you can use the extension [vscode-ltex](https://github.com/valentjn/vscode-ltex).\n\n## Links\n\n- [LanguageTool][lt]\n- [ltex-ls][ltexls]\n- [Note talking with Helix, Tp-Note and LanguageTool][getreu]\n\n[helix]: https://helix-editor.com\n[lt]: https://languagetool.org/\n[getreu]: https://blog.getreu.net/20220828-tp-note-new8/\n[ltexls]: https://valentjn.github.io/ltex/\n\n\n<hr />\n\nThank you for reading my blog.\n\nDon't hesitate to reach out via [email](mailto:hi@rockyourcode.com\") or [Mastodon](undefined)!\n"}