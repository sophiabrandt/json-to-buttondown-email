{"titles":[" Write Better in Neovim With Languagetool"," TIL About GNU Stow to Manage Dotfiles"," Helix Editor â€“ 90% of Neovim With Kakoune"," Setting Up a Modern Preact Application With Typescript, Vite and Vitest"],"content":"Hello ðŸ‘‹! Thanks for subscribing.\n\n\nHere are my latest articles:\n\n## [Write Better in Neovim With Languagetool](https://www.rockyourcode.com/write-better-in-neovim-with-languagetool/)\n\nPublished on: 2022-10-02\n\ntags: DevTools, Vim\n\n\n**[LanguageTool][lt]** is a grammar tool and spell checker with an open-source core.\n\nI have used [grammarly](https://www.grammarly.com/) for a while, but the browser extension was crap.  \nA colleague recommended LanguageTool (LT), and I've been a happy user of the browser extension ever since.\n\nLT has superior support for other languages than English.\nIt also features decent suggestions for improving your grammar.\nThe free tier of LT has been a better experience for me than grammarly.\n\nDid you know that you can use LT as a language server for NeoVim and other editors?\n\n## Install ltex-ls\n\nLT has no direct support for the [language server protocol](https://microsoft.github.io/language-server-protocol/), but fear not â€“ a clever programmer has included the LT server in his LSP implementation.\n\nThe tool is called **[ltex-ls][ltexls]**, and it's free software.\n\nYou can find the installation instructions on the [ltex-ls website](https://valentjn.github.io/ltex/ltex-ls/installation.html).\n\nFor macOS, you can use [homebrew](https://brew.sh):\n\n```bash\nbrew install ltex-ls\n```\n\nThe command installs the server as `ltex-ls` in your standard homebrew location and thus adds it to your `$PATH`.\n\nIf you manually install the program, make sure to add the binary to your `$PATH`, for example with [`fish_add_path`](https://fishshell.com/docs/current/cmds/fish_add_path.html).\n\n## Integration With nvim-lsp\n\nCheck the [recommended configuration on the nvim-lsp GitHub](https://github.com/neovim/nvim-lspconfig#suggested-configuration) and add the following configuration:\n\n```lua\nrequire('lspconfig')['ltex']({\n  on_attach = on_attach,\n  cmd = { \"ltex-ls\" },\n  filetypes = { \"markdown\", \"text\" },\n  flags = { debounce_text_changes = 300 },\n})\n```\n\nYou should add the server command into the `cmd` section. On macOS, `ltex-ls` worked fine for me.\n\nHere you can see how the tool points out possible errors in my text:\n\n![neovim languagetool example](/languagetool-neovim.png)\n\n## Other Editors\n\nI originally found the instructions for using ltex-lsp on a blog about the [Helix Editor][helix]: [Note talking with Helix, Tp-Note and LanguageTool][getreu].\n\nHere is the the content of `~/.config/helix/languages.toml`:\n\n```toml\n[[language]]\nfile-types = [\"md\", \"txt\"]\nindent = { tab-width = 2, unit = \"  \" }\ninjection-regex = \"md|markdown\"\nlanguage-server = { command = \"ltex-ls\" }\nname = \"markdown\"\nroots = [\".git\"]\nscope = \"source.md\"\n```\n\nIf you use [VS Code](https://code.visualstudio.com/), you can use the extension [vscode-ltex](https://github.com/valentjn/vscode-ltex).\n\n## Links\n\n- [LanguageTool][lt]\n- [ltex-ls][ltexls]\n- [Note talking with Helix, Tp-Note and LanguageTool][getreu]\n\n[helix]: https://helix-editor.com\n[lt]: https://languagetool.org/\n[getreu]: https://blog.getreu.net/20220828-tp-note-new8/\n[ltexls]: https://valentjn.github.io/ltex/\n\n\n<hr />\n## [TIL About GNU Stow to Manage Dotfiles](https://www.rockyourcode.com/til-about-gnu-stow-to-manage-dotfiles/)\n\nPublished on: 2022-09-26\n\ntags: DevTools, TIL\n\n\nToday I learned about the tool [GNU Stow][stow], a free program that helps with managing symbolic links on your system.\n\nWhat does that even mean?\n\nI store my user configuration in a [dotfile](https://dotfiles.github.io/).  \nUsing Git, I can synchronize my settings across different machines.  \nNow I have a backup, even if I lose my computer, or it breaks.\n\nSo far, I've used [symlinks](https://www.freecodecamp.org/news/symlink-tutorial-in-linux-how-to-create-and-remove-a-symbolic-link/) to create a link on my machine to the central git repository.\n\nBut I learned about a great utility called **[GNU Stow][stow]** that helps with managing dotfiles. Stow makes neat symbolic links in the right location.\n\nYou can easily pick and choose which configurations you want to sync.\n\nSo, let's say your dotfiles repository looks like this:\n\n```bash\n$ tree -a ~/dotfiles\n.\nâ”œâ”€â”€ bash\nâ”‚   â”œâ”€â”€ .bashrc\nâ”‚   â””â”€â”€ .bash_profile\nâ”œâ”€â”€ kitty\nâ”‚   â””â”€â”€ .config\nâ”‚       â””â”€â”€ kitty\nâ”‚           â””â”€â”€ kitty.conf\nâ””â”€â”€ vim\n    â””â”€â”€ .vimrc\n```\n\nThen you can use stow like this:\n\n```bash\nstow bash\nstow kitty\nstow vim\n```\n\n## Links\n\nYou can find detailed explanations here:\n\n- [Managing dotfiles with GNU stow](https://alexpearce.me/2016/02/managing-dotfiles-with-stow/)\n- [Using GNU Stow to manage your dotfiles](https://brandon.invergo.net/news/2012-05-26-using-gnu-stow-to-manage-your-dotfiles.html)\n\nThanks to [Sandra Parsick](http://www.sandra-parsick.de/) and [Georg Berky](https://georg.berky.dev/) for introducing me to this tool.\n\n[stow]: https://www.gnu.org/software/stow/\n\n\n<hr />\n## [Helix Editor â€“ 90% of Neovim With Kakoune](https://www.rockyourcode.com/helix-editor-90-percent-of-neovim-with-kakoune/)\n\nPublished on: 2022-09-22\n\ntags: DevTools, Vim\n\n\nI've spend too many hours setting up the recent NeoVim features (since v0.5): [tree-sitter][tree-sitter], [nvim-lsp][nvim-lsp], [nvim-cmp][nvim-cmp].\n\nWhy?  \nNeoVim's parser tool [tree-sitter][tree-sitter] offers a better integration of language servers, syntax highlighting and auto-completion.\n\n## The Problem\n\nVim and NeoVim are great.  \nHowever, I put a lot of effort into customizing these editors to my liking, so that I could comfortably use them for coding.\n\nIn fact, my [configuration][vimdotfiles] has become more complicated over the years.\n\nMigrating my Vim configuration to take advantage of tree-sitter was an exercise in frustration.\n\n## Better Than (Neo)Vim?\n\nBy chance I stumbled upon a review of [Rust text editors][rte] on [lobste.rs](https://lobste.rs).\n\nThe article favorably mentions **[Helix][helix]**, a modal text editor inspired by Vim and [Kakoune][kakoune].  \nOther commentators also seemed taken with this new text editor.\n\n![helix text editor](https://github.com/helix-editor/helix/raw/master/screenshot.png)\n\nI gave Helix a try and I am pleasantly surprised.\n\nHelix is a fully-fledged text editor that comes with wonderful capabilities out of the box.  \nFor example, you get a fuzzy file finder, language server integration, a [vim-surround](https://github.com/tpope/vim-surround)-like plugin and great editor themes for free.\n\nIn the end, Helix offers almost everything I need from a terminal-based text editor _with zero config_.\n\nAfter wasting hours of my free time on tweaking NeoVim, Helix's sane defaults and inbuilt features blew me out of the water.\n\n## Kakoune â€“ Why!?\n\nHelix has one advantage over Vim/NeoVim - multiple cursors.\nThis features makes text editing a smoother experience.\n\nMultiple cursors come from [Kakoune][kakoune], a text editor I never heard of.\n\nVim's core editing model revolves around _verbs_ and _(text) objects_.\nFor example, to delete a word, you type `dw`, like in a natural language like English.\n\nKakoune turns this model on its head: in Kakoune, you always select text objects first, then operate on them with words.\n\nHelix uses the same model as Kakoune.  \nThe idea is that you always start by making a selection first (that way it's interactive and you see that you selected the right thing), then you operate on it.\n\nI'm not sure if I can forego my muscle memory and retrain myself to use the \"Kakoune\" way.\nFor me, it feels incredibly awkward.\n\nI am also missing some commands in normal mode.  \nFor example, I can easily move or copy lines to other locations in the file [without having to make a selection and without leaving normal mode](https://www.rockyourcode.com/til-about-copying-a-range-in-vim/).  \nThis is a clash with Kakoune's/Helix's philosophy.\n\nWhat I am missing most is `ci` (for `change inside`).  \nI often use this command to change text in brackets (`ci{`), single quotes (`ci'`) or other text objects.\n\n## Now What?\n\nHelix is in active development.  \nBut even so, the editor is already usable. Because it is written in Rust, it's fast and stable.\n\nThe maintainers plan a [plugin system with WebAssembly](https://github.com/helix-editor/helix/issues/122), which would be a big milestone for the project.\n\nAll in all, Helix looks like a valid alternative to Vim/NeoVim if you like modal editors.\n\n# My Configuration\n\nHere is my complete configuration file:\n\n```toml\ntheme = \"nord\"\n\n[editor.cursor-shape]\ninsert = \"bar\"\nnormal = \"block\"\nselect = \"underline\"\n\n[editor.statusline]\nleft = [\"mode\", \"diagnostics\"]\ncenter = [\"file-name\"]\nright = [\"selections\", \"file-type\", \"file-encoding\", \"position-percentage\", \"position\"]\n\n[keys.normal]\ng = { a = \"code_action\", o = \"goto_last_accessed_file\" }\n\"ret\" = [\"move_line_down\", \"goto_first_nonwhitespace\"] # Maps the enter key to move to start of next line\nX = \"extend_line_above\"\nD = \"delete_char_backward\"\n\n[keys.insert]\nC-space = \"completion\"\n# Move cursor in insert mode\nA-h = \"move_char_left\"\nA-j = \"move_line_down\"\nA-k = \"move_line_up\"\nA-l = \"move_char_right\"\nA-o = \"open_below\"\nA-O = \"open_above\"\n```\n\nIt adds a default theme, a few convenience key mappings plus some customization around the status-line and the cursor.\n\nIn comparison, here is [my code for the status-line in Vim/NeoVim _alone_](https://github.com/sophiabrandt/dotfiles/blob/main/vim/plugin/statusline.vim) â€“ which is (more or less) a three-liner in Helix.\n\n## Links\n\n- [Helix][helix]\n- [Kakoune][kakoune]\n- [Reviewing some new Rust text editors](https://lobste.rs/s/xyexnb/reviewing_some_new_rust_text_editors)\n\n[kakoune]: http://kakoune.org/\n[tree-sitter]: https://tree-sitter.github.io/tree-sitter/\n[helix]: https://helix-editor.com/\n[nvim-lsp]: https://github.com/neovim/nvim-lspconfig\n[nvim-cmp]: https://github.com/hrsh7th/nvim-cmp\n[vimdotfiles]: https://github.com/sophiabrandt/dotfiles/tree/main/vim\n[rte]: https://matduggan.com/battle-of-the-text-editors/\n\n\n<hr />\n## [Setting Up a Modern Preact Application With Typescript, Vite and Vitest](https://www.rockyourcode.com/setting-up-a-modern-preact-application-with-typescript-vite-and-vitest/)\n\nPublished on: 2022-09-19\n\ntags: TypeScript, React.js, Preact.js, Testing\n\n\n> Wiring up a TypeScript environment with Preact, Vite and Vitest and vitest-dom\n\nI have heard good things about Vite and Vitest. When I gave them a test-drive, I stumbled over some minor annoyances in getting the whole suite running.\n\nI'm writing down the steps I took, maybe they help you.\n\nThe article is basically a re-write of [a blog post by Tomoki Miyaci][miyauci] adjusted to my needs.\n\nTooling:\n\n- TypeScript\n- Vite\n- Vitest (with vitest-dom)\n- Preact\n- Prettier\n- ESLint\n- husky & lint-staged\n- commitlint\n\nAll my commands use [pnpm](https://pnpm.io), feel free to replace them with npm or yarn.\n\n## Vite\n\n```sh\npnpm create vite <project-name> --template preact-ts\ncd <project-name>\npnpm install\n```\n\n## ESLint & prettier\n\n```sh\npnpm i -D eslint eslint-config-prettier \\\n          prettier \\\n          @typescript-eslint/parser\n```\n\nCreate a new file called `.eslintrc` with the following content:\n\n```json\n{\n  \"env\": {\n    \"browser\": true,\n    \"es2021\": true\n  },\n  \"extends\": [\"eslint:recommended\", \"preact\", \"prettier\"],\n  \"parser\": \"@typescript-eslint/parser\",\n  \"parserOptions\": {\n    \"ecmaFeatures\": {\n      \"jsx\": true\n    },\n    \"ecmaVersion\": \"latest\",\n    \"sourceType\": \"module\"\n  },\n  \"settings\": {\n    \"jest\": {\n      \"version\": 27\n    }\n  },\n  \"ignorePatterns\": [\"*.d.ts\"],\n  \"rules\": {}\n}\n```\n\nOne wrinkle was the Jest settings option. I know I wanted to use Vite, but eslint needs to know the Jest version for some of its tests.\n\nPrettier configuration (`.prettierrc`), adjust to your needs:\n\n```\n{\n  \"trailingComma\": \"es5\",\n  \"semi\": false,\n  \"singleQuote\": true\n}\n```\n\nLet's adjust `package.json`:\n\n```json\n{\n  \"scripts\": {\n    \"lint:fix\": \"eslint --fix --ext .ts,tsx --ignore-path .gitignore .\",\n    \"prettier:write\": \"prettier -u -w --ignore-path .gitignore \\\"*.{ts,tsx,css,html}\\\"\",\n}\n```\n\n## husky & lint-staged\n\nConfigure [lint-staged](https://www.npmjs.com/package/lint-staged) inside `package.json`:\n\n```json\n{\n  \"lint-staged\": {\n    \"*.{ts,tsx}\": [\"pnpm run lint:fix\", \"pnpm run prettier:write\"],\n    \"*.{html,css,js,json}\": \"pnpm run prettier:write\"\n  }\n}\n```\n\nWe run ESLint and prettier on TypeScript files in sequential order. For other files, prettier suffices.\n\nNow we need [husky](https://typicode.github.io/husky/#/).\n\nWe initialize it with a script:\n\n```sh\npnpm dlx husky-init && pnpm install\n```\n\nThe above command will setup the tool and create the necessary files and hooks.\n\nThe default hook runs before committing the files to the staging area.  \nYou can find it under `.husky/pre-commit`:\n\n```sh\n#!/usr/bin/env sh\n. \"$(dirname -- \"$0\")/_/husky.sh\"\n\npnpm exec lint-staged\n## if you want to run your tests before commiting,\n## uncomment next line\n# pnpm exec vitest run\n```\n\n## commitlint\n\n> commitlint checks if your commit messages meet the [conventional commit](https://conventionalcommits.org/) format.\n\nExample:\n\n> chore: run tests on travis ci\n\nI personally find it quite useful to enforce a uniform commit style.  \n[commitlint](https://github.com/conventional-changelog/commitlint/) pairs well with husky.\n\n```sh\npnpm add -D @commitlint/{config-conventional,cli}\n```\n\nLet's add a configuration file (`.commitlintrc.json`):\n\n```sh\n{\n  \"extends\": [\"@commitlint/config-conventional\"]\n}\n```\n\nNow we need a hook for husky. Run the following command in your terminal:\n\n```sh\npnpm dlx husky add \\\n  .husky/commit-msg 'pnpm exec commitlint --edit'\n```\n\n## Vitest\n\nInstallation:\n\n```sh\npnpm add -D vitest vitest-dom happy-dom\n```\n\n[vitest-dom](https://github.com/chaance/vitest-dom) extends the standard Jest matchers with convenient methods like `.toBeDisabled`.  \nNow you can write tests that assert on the state of the DOM.  \nThe package is a fork of [@testing-library/jest-dom](https://github.com/testing-library/jest-dom).\n\nConfiguring vitest with the `.vite.config.ts`:\n\n```ts\n/// <reference types=\"vitest\" />\nimport { fileURLToPath } from 'url'\nimport { defineConfig } from 'vite'\nimport preact from '@preact/preset-vite'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  define: {\n    'import.meta.vitest': 'undefined',\n  },\n  plugins: [preact()],\n  test: {\n    environment: 'happy-dom',\n    setupFiles: ['./__test__/test-setup.ts'],\n    includeSource: ['src/**/*.{ts,tsx}'],\n    coverage: {\n      reporter: ['text-summary', 'text'],\n    },\n    mockReset: true,\n    restoreMocks: true,\n  },\n})\n```\n\nThe code section `import.meta.vitest` allows you to [run tests within your source code](https://vitest.dev/guide/in-source.html).\n\nFor my test setup I've made a separate `__test__` folder with a file called `test-setup.ts`:\n\n```ts\nimport 'vitest-dom/extend-expect'\nimport * as domMatchers from 'vitest-dom/matchers'\nimport { expect } from 'vitest'\n\nexpect.extend(domMatchers)\n```\n\nHere I add the `vitest-dom` extra matchers. You can add more setup logic if needed.\n\n## Sources\n\n- [Building a Typescript Environment for Preact with Vite][miyauci]\n- [Diving Into Husky and lint-staged][laurie]\n\n[laurie]: https://laurieontech.com/posts/husky/\n[miyauci]: https://miyauchi.dev/posts/vite-preact-typescript/\n\n\n<hr />\n\nThank you for reading my blog.\n\nDon't hesitate to reach out via [email](mailto:hi@rockyourcode.com\") or [Twitter](https://twitter.com/hisophiabrandt)!\n"}