{"titles":[" Apollo Server Express 3 With Typescript"," Inline Critical CSS With Hugo Pipes"," Node.js Setup With TypeScript, Nodemon and ESM"," Create a PostCSS Pipe With Hugo"," How to Setup React Typescript With Snowpack and Daisy UI"," Emptty â€” a Minimal Display Manager"," Create a Blazingly Fast Static Site With Zola"],"content":"Hello ðŸ‘‹! Thanks for subscribing.\n\n\nHere are the articles from last week:\n\n## [Apollo Server Express 3 With Typescript](https://www.rockyourcode.com/apollo-server-express-3-with-typescript/)\n\nPublished on: 2021-10-17\n\ntags: GraphQL, TypeScript, JavaScript, Node.js\n\n\n> apollo-server-express GraphQL + TypeScript + esm\n\nApollo released [Apollo Server 3][server3] in July 2021 with the goal of offering more flexibility and a leaner code-base to build new features.\n\nThe core package for the server is [apollo-server][apollo-server]. If you want to integrate Apollo into an existing Express application or wish to use more advanced features, you'll need [apollo-server-express][ase].\n\nThe [documentation][documentation] is user-friendly but does not provide a turn-key solution to get you started.  \nApollo Server Express needs to start asynchronously which caused some problems.\n\nIn this article, I'll show you the steps to create a simple Apollo Server with TypeScript, nodemon, ts-node and [ESM (ES Modules)][esm].\n\n## Skeleton\n\nCreate a new project with `npm` (you'll need Node.js 12 or later).\n\nI use Linux, so the code in my blog post works for Unix. If you're a Windows user, you'll probably need to adjust some of the commands.\n\n```bash\nmkdir apollo-3-ts && cd apollo-3-ts\nnpm init -y\n```\n\nInstall dependencies:\n\n```bash\nnpm i apollo-server-express apollo-server-core express graphql\nnpm i --save-dev typescript nodemon ts-node ts-watch @types/node @types/express\n```\n\nSetup TypeScript:\n\n```bash\nnpx tsc --init\n```\n\nThe above command creates a new file called `tsconfig.json`. Adjust the following parts in the file:\n\n```json\n{\n  \"module\": \"ES2020\",\n  \"moduleResolution\": \"Node\",\n  \"outDir\": \"./dist\"\n}\n```\n\nCompiled files (from TypeScript to JavaScript) will land in the dist folder.\n\nAdd these lines to `package.json` to enable ECMAScript modules and allow imports from your compiled TypeScript files:\n\n```json\n{\n  \"type\": \"module\",\n  \"exports\": \"./dist/index.js\"\n}\n```\n\nNow, we will add a script for the development server into `package.json`:\n\n```json\n{\n  \"scripts\": {\n    \"watch\": \"nodemon --watch './**/*.{ts,graphql}' -r dotenv/config --exec 'node --experimental-specifier-resolution=node --loader ts-node/esm' src/index.ts\",\n    \"dev\": \"npx tsc-watch --onSuccess \\\"npm run watch\\\"\"\n  }\n}\n```\n\nYou can find more details in the links at the end of the article.\n\n## Apollo Server Setup\n\nCreate a new folder called `src` with a file `index.ts`.\n\n```bash\nmkdir src && touch src/index.ts\n```\n\nYou should now have a file structure like this:\n\n```bash\napollo-3-ts <- folder name\nâ”œâ”€â”€ node_modules\nâ”œâ”€â”€ package.json\nâ”œâ”€â”€ package-lock.json\nâ”œâ”€â”€ src\nâ”‚Â Â  â””â”€â”€ index.ts\nâ””â”€â”€ tsconfig.json\n```\n\nCopy the next code snippet into `src/index.ts`. The code is [from the documentation][documentation] with [a fix to promisify the http listener][promisify] with TypeScript.\n\n```ts\nimport { ApolloServer, gql } from 'apollo-server-express'\nimport { ApolloServerPluginDrainHttpServer } from 'apollo-server-core'\nimport express from 'express'\nimport http from 'http'\n\nconst typeDefs = gql`\n  type Query {\n    hello: String\n  }\n`\n\nconst resolvers = {\n  Query: {\n    hello() {\n      return 'world'\n    },\n  },\n}\n\nasync function listen(port: number) {\n  const app = express()\n  const httpServer = http.createServer(app)\n\n  const server = new ApolloServer({\n    typeDefs,\n    resolvers,\n    plugins: [ApolloServerPluginDrainHttpServer({ httpServer })],\n  })\n  await server.start()\n\n  server.applyMiddleware({ app })\n\n  return new Promise((resolve, reject) => {\n    httpServer.listen(port).once('listening', resolve).once('error', reject)\n  })\n}\n\nasync function main() {\n  try {\n    await listen(4000)\n    console.log('ðŸš€ Server is ready at http://localhost:4000/graphql')\n  } catch (err) {\n    console.error('ðŸ’€ Error starting the node server', err)\n  }\n}\n\nvoid main()\n```\n\nThe code bootstraps the Apollo server with a minimal \"Hello, world\" resolver to get you started.\n\nNow you can fire off the server from the command line:\n\n```bash\nnpm run dev\n```\n\nYou should be able to reach the GraphQL endpoint in your browser under `http://localhost:4000/graphql` and Apollo Studio should pop up.\n\n## Thoughts\n\nIt was tricky to find out how to get the [documentation example][documentation] to work as it needs a JavaScript promise to listen to the server.\n\nLuckily, [GitHub][promisify] had the solution. I only needed to know what to look for.\n\n## Links\n\n- [Choosing an Apollo Server package][documentation]\n- [Typescript And Native esm on Node.js](https://2ality.com/2021/06/typescript-esm-nodejs.html)\n- [Node.js Setup With TypeScript, Nodemon and ESM][tsesm]\n- [Unable to import ESM .ts module in node][so]\n- [Promisify server.listen][promisify]\n\n[promisify]: https://github.com/nodejs/node/issues/21482\n[server3]: https://www.apollographql.com/blog/announcement/backend/its-here-introducing-apollo-server-3/\n[apollo-server]: https://npm.im/apollo-server\n[ase]: https://npm.im/apollo-server-express\n[esm]: https://2ality.com/2021/06/typescript-esm-nodejs.html\n[documentation]: https://www.apollographql.com/docs/apollo-server/integrations/middleware/#apollo-server-express\n[tsesm]: https://www.rockyourcode.com/nodejs-setup-with-typescript-nodemon-and-esm/\n[so]: https://stackoverflow.com/questions/63742790/unable-to-import-esm-ts-module-in-node\n\n\n<hr />\n## [Inline Critical CSS With Hugo Pipes](https://www.rockyourcode.com/inline-critical-css-with-hugo-pipes/)\n\nPublished on: 2021-10-03\n\ntags: Hugo\n\n\n> How to inline critical CSS transformed via Hugo Pipes\n\nI use [Hugo pipes][pipes] to process my CSS files written in Sass.\n\nExample:\n\n```go-html-template\n{{- $critical := resources.Get \"scss/critical.scss\" | resources.ToCSS }}\n{{- if hugo.IsProduction }}\n{{- $critical = resources.Get \"scss/critical.scss\" | resources.ToCSS | resources.Minify }}\n{{- end }}\n<head>\n  <link rel=\"stylesheet\" href=\"{{ $critical.RelPermalink }}\" />\n// more code\n```\n\nEasy, peasy. I can use the optimized CSS as an external link to my stylesheet.\n\nBut how can I inline CSS?\n\nThe [Hugo documentation][docs] is extensive, but sometimes it's hard to find what you need.\n\nThe solution is easy after all, but it still took me two days to find.\n\nYou need to take the Hugo resource's content and pipe it to the [safeCSS][safecss] function:\n\n```go-html-template {linenos=table,hl_lines=[6]}\n{{- $critical := resources.Get \"scss/critical.scss\" | resources.ToCSS }}\n{{- if hugo.IsProduction }}\n{{- $critical = resources.Get \"scss/critical.scss\" | resources.ToCSS | resources.Minify }}\n{{- end }}\n<head>\n  <style>{{ $critical.Content | safeCSS }}</style>\n// more code\n```\n\n## Resources\n\n- [Hugo Pipes Introduction][pipes]\n- [Inlining Critical Path CSS with Hugo Pipes](https://discourse.gohugo.io/t/inlining-critical-path-css-with-hugo-pipes/12998)\n\n[pipes]: https://gohugo.io/hugo-pipes/introduction/\n[safecss]: https://gohugo.io/functions/safecss\n[docs]: https://gohugo.io/\n\n\n<hr />\n## [Node.js Setup With TypeScript, Nodemon and ESM](https://www.rockyourcode.com/nodejs-setup-with-typescript-nodemon-and-esm/)\n\nPublished on: 2021-10-01\n\ntags: TypeScript, Node.js, JavaScript\n\n\n> Let's try to set up a Node.js/Express.js TypeScript project with nodemon and ESM!\n\nYesterday someone in the [ZTM Discord server][ztmdiscord] asked if it was possible to use `nodemon` with TypeScript and native ECMAScript modules.\n\nIt is!\n\nI used Node.js (version 14 works) and a bit of internet sleuthing to figure out how to do it.\n\n## TypeScript\n\nCreate a new directory. Inside that directory, we'll need to initialize a new Node.js project:\n\n```bash\nnpm init -y\n```\n\nNow for the dependencies. First, [Express.js][express]:\n\n```bash\nnpm i express\n```\n\nAs development dependencies, we use TypeScript, [nodemon][nodemon], [ts-node][tsnode] and the necessary types:\n\n```bash\nnpm i --save-dev typescript nodemon ts-node @types/node @types/express\n```\n\nNow, TypeScript setup:\n\n```bash\nnpx tsc --init\n```\n\nThe above command creates a new file called `tsconfig.json`. Adjust the following parts in the file:\n\n```json\n{\n  \"module\": \"ES2020\",\n  \"moduleResolution\": \"Node\",\n  \"outDir\": \"./dist\"\n}\n```\n\nCompiled files (from TypeScript to JavaScript) will land in the dist folder.\n\nAdd these lines to `package.json` to enable ECMAScript modules and allow imports from your compiled TypeScript files:\n\n```json\n{\n  \"type\": \"module\",\n  \"exports\": \"./dist/index.js\"\n}\n```\n\n## Minimal Server\n\nLet's create our source code. Make a new folder called `src` and add a file called `index.ts` inside that directory.\n\nHere's a minimal Express server:\n\n```ts\nimport express, { Request, Response } from 'express'\n\nconst app = express()\nconst port = 5000\n\napp.get('/', (req: Request, res: Response) => {\n  res.json({ greeting: 'Hello world!' })\n})\n\napp.listen(port, () => {\n  console.log(`ðŸš€ server started at http://localhost:${port}`)\n})\n```\n\n## Wiring Up Scripts\n\nNow, the magic will come together. Add the following script to `package.json`:\n\n```json\n{\n  \"scripts\": {\n    \"dev:server\": \"nodemon --watch './**/*.ts' --exec 'node --experimental-specifier-resolution=node --loader ts-node/esm' src/index.ts\"\n  }\n}\n```\n\nFirst, we'll use `nodemon` with the `--watch` flag to keep track of all TypeScript files. We can use `--execute` to run other scripts.\n\nWe use the [experimental loader feature with hooks][expf] to run `ts-node`. We need the library so that we can directly run TypeScript on Node.js:\n\n> It JIT transforms TypeScript into JavaScript, enabling you to directly execute TypeScript on Node.js without precompiling. This is accomplished by hooking node's module loading APIs, enabling it to be used seamlessly alongside other Node.js tools and libraries.\n\nStart the server now:\n\n```bash\nnpm run dev:server\n```\n\nYay, it works!\n\n## Importing Files\n\nYou probably want to split up your code into different files and import them.\n\n_You cannot import a TypeScript file directly._\n\nThat means that **you first have to transpile all TypeScript files it into JavaScript** and then import the JavaScript files.\n\nUsing the `node --experimental-specifier-resolution=node` in the start command is a first step. Enabling the flag allows you to use the standard import syntax without using a file ending. This works as known:\n\n```ts\nimport { blababla } from './some-folder/some-file'\n```\n\nI will use [ts-watch](https://www.npmjs.com/package/tsc-watch) to run `tsc` in watch mode and delegate to `nodemon` if the compilation is successful.\n\n```bash\nnpm install --save-dev ts-watch\n```\n\nAdjust `package.json`:\n\n```json\n{\n  \"scripts\": {\n    \"watch\": \"nodemon --watch './**/*.{ts,graphql}' -r dotenv/config --exec 'node --experimental-specifier-resolution=node --loader ts-node/esm' src/index.ts\",\n    \"dev\": \"npx tsc-watch --onSuccess \\\"npm run watch\\\"\"\n  }\n}\n```\n\n`tsc` will write the JavaScript files into the specified `outDir` location (see `tsconfig.json`). We've set the folder to `./dist`.\n\nIn `package.json` we added an `exports` key-value-pair which allows us to import those transpiled files from the `dist` folder _as if they were the original TypeScript files_.\n\nLet's say that you have a folder structure like this:\n\n```bash\n.\nâ”œâ”€â”€ dist\nâ”‚Â Â  â”œâ”€â”€ index.js\nâ”‚Â Â  â”œâ”€â”€ services\nâ”‚Â Â  â”‚Â Â  â””â”€â”€ accounts\nâ”‚Â Â  â”‚Â Â      â”œâ”€â”€ index.js\nâ”‚Â Â  â”‚Â Â      â”œâ”€â”€ resolvers.js\nâ”‚Â Â  â”‚Â Â      â””â”€â”€ typeDefs.js\nâ”‚Â Â  â””â”€â”€ utils\nâ”‚Â Â      â””â”€â”€ apollo.js\nâ”œâ”€â”€ node_modules\nâ”œâ”€â”€ package.json\nâ”œâ”€â”€ package-lock.json\nâ”œâ”€â”€ src\nâ”‚Â Â  â”œâ”€â”€ index.ts\nâ”‚Â Â  â”œâ”€â”€ services\nâ”‚Â Â  â”‚Â Â  â””â”€â”€ accounts\nâ”‚Â Â  â”‚Â Â      â”œâ”€â”€ index.ts\nâ”‚Â Â  â”‚Â Â      â”œâ”€â”€ resolvers.ts\nâ”‚Â Â  â”‚Â Â      â””â”€â”€ typeDefs.ts\nâ”‚Â Â  â””â”€â”€ utils\nâ”‚Â Â      â””â”€â”€ apollo.ts\nâ””â”€â”€ tsconfig.json\n\n```\n\nIn `src/index.ts` you want to import something from `src/services/accounts/index.ts`. It works like normal JavaScript _even though the files are TypeScript files_:\n\n```js\n// src/index.ts\nimport { startApolloServer } from './services/accounts/index'\n```\n\nNode.js will use your configuration to import the according JavaScript file under the hood.\n\n## Thoughts\n\nIt was a bit tricky to find out how to pair `nodemon` with the Node.js loader feature. While you'll get console warnings about using this experimental feature, it works fine on the latest Node.js v14.\n\nSuccess.\n\n## Resources\n\n- [Use TypeScript to Build a Node API with Express](https://developer.okta.com/blog/2018/11/15/node-express-typescript)\n- [TypeScript and native ESM on Node.js](https://2ality.com/2021/06/typescript-esm-nodejs.html)\n- [ts-node on GitHub][expf]\n- [Restart Your Server When Changing Your TypeScript Code](https://futurestud.io/tutorials/typescript-use-nodemon-to-restart-your-server-on-changes)\n- [Unable to import ESM .ts module in node][so]\n\n[ztmdiscord]: https://zerotomastery.io/\n[nodemon]: https://www.npmjs.com/package/nodemon\n[tsnode]: https://www.npmjs.com/package/ts-node\n[express]: https://expressjs.com/\n[expf]: https://github.com/TypeStrong/ts-node/issues/1007\n[so]: https://stackoverflow.com/questions/63742790/unable-to-import-esm-ts-module-in-node\n\n\n<hr />\n## [Create a PostCSS Pipe With Hugo](https://www.rockyourcode.com/create-a-postcss-pipe-with-hugo/)\n\nPublished on: 2021-09-24\n\ntags: Hugo\n\n\nI'm trying to create a new theme for Hugo.\n\nHugo offers powerful features, for example, **[Hugo pipes][pipes]**. Pipes allow you to transform data in your Hugo templates.\n\nI want to use [PurgeCSS][purgecss] to remove unused CSS from my production bundle.\n\nThe official website has [a guide for using PostCSS with Hugo][postcss], but it was not 100% clear to me how to use the instructions.\n\n## 1. Template\n\nYou will have a html template in your `themes` folder. Mine has the folllowing path: `themes/<name-of-theme>/layouts/partials/head.html`:\n\n```go-html-template\n{{- $critical := resources.Get \"scss/critical.scss\" | resources.ToCSS }}\n{{- $fonts := resources.Get \"scss/fonts.scss\" | resources.ToCSS | resources.Minify | resources.Fingerprint }}\n{{- if hugo.IsProduction }}\n{{- $critical = resources.Get \"scss/critical.scss\" | resources.ToCSS |  resources.PostProcess | resources.Minify | resources.Fingerprint }}\n{{- end }}\n<head>\n  <meta charset=\"UTF-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\n  <link rel=\"stylesheet\" href=\"{{ $critical.RelPermalink }}\" />\n  <link rel=\"stylesheet\" media=\"print\" href=\"{{ $fonts.RelPermalink }}\" onload=\"this.media='all'\" />\n  <title>\n    {{ if not .IsHome }}{{ with .Title }}{{ . }} | {{ end }}{{ end }}{{\n    .Site.Title }}\n  </title>\n  <meta\n    name=\"description\"\n    content=\"{{ with .Description }}{{ . }}{{ else }}{{ with .Summary }}{{ . }}{{ else }}{{ .Site.Params.description }}{{end }}{{ end }} \"\n  />\n  {{ template \"_internal/opengraph.html\" . }}\n  {{ template \"_internal/twitter_cards.html\" . }}\n  {{ template \"_internal/schema.html\" . }}\n</head>\n```\n\nIf we make a production build with the command `hugo`, we will process the Sass SCSS file with several transformations.\n\n## 2. Main Folder\n\nThe above code sits in the `theme` folder, nested in your main Hugo project.\n\nExample folder structure:\n\n```bash\nâ”œâ”€â”€ archetypes\nâ”‚Â Â  â””â”€â”€ default.md\nâ”œâ”€â”€ config.toml\nâ”œâ”€â”€ content\nâ”‚Â Â  â”œâ”€â”€ about.md\nâ”‚Â Â  â””â”€â”€ blog\nâ”‚Â Â      â”œâ”€â”€ 2021\nâ”‚Â Â      â”‚Â Â  â”œâ”€â”€ hipsum.md\nâ”‚Â Â      â”‚Â Â  â””â”€â”€ lorem-ipsum.md\nâ”‚Â Â      â””â”€â”€ _index.md\nâ”œâ”€â”€ data\nâ”œâ”€â”€ layouts\nâ”œâ”€â”€ static\nâ””â”€â”€ themes\n    â””â”€â”€ sample-hugo-theme\n        â”œâ”€â”€ archetypes\n        â”‚Â Â  â””â”€â”€ default.md\n        â”œâ”€â”€ assets\n        â”‚Â Â  â””â”€â”€ scss\n        â”‚Â Â      â”œâ”€â”€ _config.scss\n        â”‚Â Â      â”œâ”€â”€ critical.scss\n        â”‚Â Â      â””â”€â”€ _reset.scss\n        â”œâ”€â”€ layouts\n        â”‚Â Â  â”œâ”€â”€ 404.html\n        â”‚Â Â  â”œâ”€â”€ blog\n        â”‚Â Â  â”‚Â Â  â””â”€â”€ single.html\n        â”‚Â Â  â”œâ”€â”€ _default\n        â”‚Â Â  â”‚Â Â  â”œâ”€â”€ about.html\n        â”‚Â Â  â”‚Â Â  â”œâ”€â”€ baseof.html\n        â”‚Â Â  â”‚Â Â  â”œâ”€â”€ list.html\n        â”‚Â Â  â”‚Â Â  â””â”€â”€ single.html\n        â”‚Â Â  â”œâ”€â”€ index.html\n        â”‚Â Â  â””â”€â”€ partials\n        â”‚Â Â      â”œâ”€â”€ footer.html\n        â”‚Â Â      â”œâ”€â”€ header.html\n        â”‚Â Â      â”œâ”€â”€ head.html\n        â”‚Â Â      â”œâ”€â”€ page-header.html\n        â”‚Â Â      â”œâ”€â”€ pagination.html\n        â”‚Â Â      â””â”€â”€ post_pagination.html\n        â”œâ”€â”€ LICENSE\n        â””â”€â”€ theme.toml\n```\n\nWe run the necessary commands from the main folder. For development mode, we use `hugo server`, for production mode, we use `hugo`.\n\nDepending on which command you run, Hugo will recognize the mode.\n\nThat means that you'll need to set configuration settings from [guide][postcss] **in the main folder** (not the themes folder where your HTML template resides).\n\nInstall the necessary Node.js dependencies **in the main Hugo directory** (same folder as `config.{toml,yaml,json}`:\n\n```bash\nnpm i -D @fullhuman/postcss-purgecss postcss postcss-cli\n```\n\nThe next parts are identical to the [documentation][postcss]:\n\nAdjust the configuration. If you use `toml`, here's the example `config.toml`:\n\n```toml\n[build]\n  writeStats = true\n```\n\nCreate a `postcss.config.js`:\n\n```js\nconst purgecss = require('@fullhuman/postcss-purgecss')({\n  content: ['./hugo_stats.json'],\n  defaultExtractor: (content) => {\n    let els = JSON.parse(content).htmlElements\n    return els.tags.concat(els.classes, els.ids)\n  },\n})\n\nmodule.exports = {\n  plugins: [\n    ...(process.env.HUGO_ENVIRONMENT === 'production' ? [purgecss] : []),\n  ],\n}\n```\n\n## 3. Production Build\n\nRun the following command inside your terminal:\n\n```bash\nhugo\n```\n\nThe command will create a `public` folder which contains the static website that you built with Hugo. Your CSS assets should work.\n\n## Thoughts\n\nIf you share your theme for others to use, _they_ will have to go through the steps of installing the Node.js dependencies in their Hugo project.\n\nI find that less than ideal, as I prefer to manage my assets from the themes folder.\n\n## Links\n\n- [PurgeCSS][purgecss]\n- [Hugo Pipes Introduction][pipes]\n- [Asset Management with Hugo: PostProcess][postcss]\n- [How I can implement Purgecss, Uncss, or PurifyCSS in Hugo?](https://discourse.gohugo.io/t/how-i-can-implement-purgecss-uncss-or-purifycss-in-hugo/24446/4)\n\n[postcss]: https://gohugo.io/hugo-pipes/postprocess/#css-purging-with-postcss\n[pipes]: https://gohugo.io/hugo-pipes/introduction/\n[purgecss]: https://purgecss.com/\n\n\n<hr />\n## [How to Setup React Typescript With Snowpack and Daisy UI](https://www.rockyourcode.com/how-to-setup-react-typescript-with-snowpack-and-daisyui/)\n\nPublished on: 2021-08-31\n\ntags: React.js, TypeScript\n\n\nThis weekend I wanted to setup a new playground for testing out some React concepts.\n\nI've decided to use **[Snowpack][snowpack]** and **[Daisy UI][daisyui]**.\n\n[Snowpack is a new build tool and bundler for JavaScript web applications.][csstricks] Under the hood it uses [esbuild][esbuild]. esbuild was written in Go and is very fast.\n\nSnowpack offers a development server and hot module replacement. It comes with a few plugins and templates to speed up setup, but its far from a zero-config tool.\n\nDaisyUI is a wrapper around [Tailwind CSS][tailwindcss], the utility-first CSS framework. DaisyUI offers convenient components that remind of the well-known [Bootstrap framework](https://www.bootstrap-ui.com/). For example, you can style a button with a simple `btn btn-primary` class in your HTML instead of stringing together several utility classes like `inline-block px-4 py-3 text-sm font-semibold text-center text-white uppercase transition duration-200 ease-in-out bg-indigo-500 rounded-md cursor-pointer hover:bg-indigo-600`.\n\nIn this article, I'll offer a \"Getting started\" for React with TypeScript and Daisy UI, using Snowpack.\n\nThe blog post borrows from [Adding Tailwind CSS to React Snowpack Project][sung] which helped me bring all parts together.\n\n## Snowpack Setup\n\nUse the snowpack template for creating a new app. You'll need [Node.js](https://nodejs.org/en/). Node.js comes with the command line utility `npx`.\n\nType the following command into your terminal:\n\n```bash\nnpx create-snowpack-app react-daisyui \\\n--template @snowpack/app-template-react-typescript \\\n--use-pnpm\n```\n\nHere we create a new application called `react-daiyui` with the template for React and TypeScript.\n\nI use [pnpm](https://pnpm.io) as the package manager of my choice, but you can use npm or yarn if you want.\n\n## Tailwind CSS\n\nNavigate into the project directory:\n\n```bash\ncd daisy-ui\n```\n\nSanity check! Try to start the project:\n\n```bash\npnpm run start # or npm run start\n```\n\nIt should now work.\n\nLet's install [Tailwind CSS][tailwindcss], [Daisy UI][daisyui] and its needed companions as development dependencies:\n\n```bash\npnpm add -D @snowpack/plugin-postcss postcss postcss-cli \\\ntailwindcss autoprefixer daisyui\n```\n\nNow we need to configure all parts so that they work together.\n\nAdjust the `snowpack.config.mjs` file in your project:\n\n```diff\n/** @type {import('snowpack').SnowpackUserConfig } */\nexport default {\n  mount: {\n    public: { url: '/', static: true },\n    src: { url: '/dist' },\n  },\n  plugins: [\n+    '@snowpack/plugin-postcss',\n   /* ... */\n   ],\n  devOptions: {\n+     tailwindConfig: './tailwind.config.js',\n  },\n  buildOptions: {\n    /* ... */\n  },\n};\n```\n\nCreate a new file called `postcss.config.js` with the following content:\n\n```js\nconst tailwindcss = require('tailwindcss')\nconst autoprefixer = require('autoprefixer')\n\nconst plugins = [tailwindcss, autoprefixer]\n\nmodule.exports = { plugins }\n```\n\n### Optional: cssnano\n\nYou can use the package [cssnano](https://cssnano.co/) to optimize the production build.\n\nInstall via pnpm/npm:\n```bash\npnpm add -D cssnano\n```\n\nUse this `postcss.config.js`:\n```js\nconst cssnano = require(\"cssnano\")\nconst tailwindcss = require(\"tailwindcss\")\nconst autoprefixer = require(\"autoprefixer\")\n\nconst plugins =\n  process.env.NODE_ENV === \"production\"\n    ? [tailwindcss, autoprefixer, cssnano]\n    : [tailwindcss, autoprefixer]\n\nmodule.exports = { plugins }\n```\n\n## Tailwind Configuration\n\nNow we need to create a configuration file for Tailwind CSS. Create a new file called `tailwind.config.js`:\n\n```js\nmodule.exports = {\n  mode: 'jit',\n  purge: ['./public/**/*.html', './src/**/*.{js,jsx,ts,tsx,vue}'],\n  plugins: [require('daisyui')],\n}\n```\n\nIf you want, you can configure Daisy UI in this file, too. See the [config section of the  Daisy UI docs](https://daisyui.com/docs/config).\n\nNow open the `src/index.css` file that snowpack generated for us. At the beginning of the file, add the following lines:\n\n```css\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n```\n\nSanity check! We can now add a new button that's styled with Daisy UI to our `src/App.tsx` file:\n\n```ts\ninterface AppProps {}\n\nfunction App({}: AppProps) {\n  return <button class=\"btn btn-primary\">DaisyUI Button</button>\n}\n\nexport default App\n```\n\nIt should now work!\n\n## Links\n\n- [Daisy UI][daisyui]\n- [Comparing the New Generation of Build Tools][csstricks] by Hugh Haworth\n- [Adding Tailwind CSS to React Snowpack Project][sung] by Sung M. Kim\n- [Snowpack: Tailwind Setup][snowtail]\n\n[csstricks]: https://css-tricks.com/comparing-the-new-generation-of-build-tools/#snowpack\n[esbuild]: https://esbuild.github.io/\n[snowpack]: https://www.snowpack.dev/\n[daisyui]: https://daisyui.com/\n[sung]: https://sung.codes/blog/2021/01/28/adding-tailwind-css-to-react-snowpack-project/\n[snowtail]: https://www.snowpack.dev/guides/tailwind-css\n[tailwindcss]: https://tailwindcss.com/\n\n\n<hr />\n## [Emptty â€” a Minimal Display Manager](https://www.rockyourcode.com/emptty-a-minimal-display-manager/)\n\nPublished on: 2021-08-28\n\ntags: Unix\n\n\nMy daily driver for my home laptop is [Manjaro Linux][manjaro].  \nManjaro is a derivative of [Arch Linux][arch]. It offers convenience and a more beginner-friendly approach at the cost of some bloat.\n\nWhile Manjaro is slightly more stable than upstream Arch Linux, it's still possible to bonk a system update.\n\nThat's what happened to me three days ago.\n\nI was able to fix almost all issues _except_ my [display manager][dm].\n\nMy Manjaro i3 installation came with [LightDM][lightdm], a login manager with a [GTK-based greeter](https://archlinux.org/packages/?name=lightdm-gtk-greeter) that fit the Manjaro aesthetic.\n\nAfter trying to fix the installation for a [few hours](https://www.debugpoint.com/2021/03/failed-to-start-lightdm/), I gave up.\n\nMy display manager is not terribly important. I need to login and start my [X11 session][x11].\n\nA simple command-line interface is enough for me, I do not need a graphical interface to log into my laptop.\n\nI've discovered **[emptty][emptty]**, a display manager that works with [X11][x11] and comes with a `systemd` script out of the box if you install the tool via [pacman](https://wiki.archlinux.org/title/Pacman).\n\n![emptty display manager](https://raw.githubusercontent.com/tvrzna/emptty/master/screenshot.png)\n\n_source: [GitHub][emptty]_\n\nIt's pretty straightforward to install on Manjaro:\n\n```bash\npacman -S emptty\n```\n\nAfter that, enable the display manager with `systemd`:\n\n```bash\nsudo systemctl enable emptty\n```\n\n[emptty][emptty] works out of the box without fuss. The CLI is not very pretty. But it works, and it hopefully won't break on my next system update.\n\n[dm]: https://wiki.archlinux.org/title/Display_manager\n[emptty]: https://github.com/tvrzna/emptty/\n[x11]: https://wiki.archlinux.org/title/Xorg\n[lightdm]: https://wiki.archlinux.org/title/LightDM\n[manjaro]: https://manjaro.org/\n[arch]: https://archlinux.org/\n\n\n<hr />\n## [Create a Blazingly Fast Static Site With Zola](https://www.rockyourcode.com/create-a-blazingly-fast-static-site-with-zola/)\n\nPublished on: 2021-08-08\n\ntags: Rust\n\n\nEvery programming language needs its [static site generator][ssg]. Rust has [3 main contenders][logrocket], one of them is **[Zola][zola]**.\n\nI wanted to try out a Rust static site generator, so let's walk through getting started with Zola.\n\n## Installation\n\nZola offers several ways of [installing](https://www.getzola.org/documentation/getting-started/installation/), even a [Dockerfile](https://www.getzola.org/documentation/getting-started/installation/#docker).\n\nFor MacOs, you can use Brew:\n\n```bash\nbrew install zola\n```\n\nFor Arch Linux (yay!):\n\n```bash\npacman -S zola\n```\n\nThat was pretty painless.\n\n## Getting started\n\nThe docs are very straight-forward. If I want to make a blog, I can follow [the outlined steps](https://www.getzola.org/documentation/getting-started/overview/#initialize-site).\n\n```bash\nzola init myblog\n```\n\nNow you'll need to answer a few questions that are self-explanatory.\n\nZola offers the option to add [search functionality to your blog](https://www.getzola.org/documentation/content/search/)! That's something that I'm missing from [Hugo](https://gohugo.io/).\n\nThe [Getting Started Guide](https://www.getzola.org/documentation/getting-started/overview/) now goes on to explain how to create templates and a folder structure.\n\nThe templating language looks like dozen others â€” which is a good thing!\n\nBut we want to add a theme and deploy the blog to [Netlify](https://netlify.com), so let's try that.\n\n## Install a Theme\n\nI want to put my blog on a free Netlify domain via GitHub.\n\nLet's initialize a new Git repository:\n\n```bash\ncd zolablog\ngit init\n```\n\n(You may need to [configure your username and email address](https://linuxize.com/post/how-to-configure-git-username-and-email/), if you haven't done so before.)\n\nAlthough the documentation does not spell it out, I'll add a theme as a [Git submodule](https://git-scm.com/book/en/v2/Git-Tools-Submodules).\n\n[Why submodules?][hugogitsubmodule]\n\n> Submodules is, in most cases, your best choice. You can easily pull in updated theme(s) when needed.\n\nThe [feather theme][feather] looks pretty nice.\n\n```bash\ngit submodule add https://github.com/piedoom/feather themes/feather\n```\n\n(If you want to update a git submodule, run `git submodule update --rebase --remote`.)\n\nNow, we need to edit the `config.toml` to add the theme. Add this line:\n\n```toml\ntheme = \"feather\"\n```\n\nStart the zola development server:\n\n```bash\nzola serve\n```\n\nYou'll see your blog on `https://localhost:1111`.\n\n## Adding Blog Posts\n\nLuckily, the theme works out of the box (that wasn't the case with all themes).\n\nI'll add a new blog post with some dummy text. For that to work, I need to add a new markdown file into the `content` folder.\n\nWe need to add [some necessary frontmatter in `.toml` format](https://www.getzola.org/documentation/content/page/#front-matter):\n\nExample post (`content/first-post.md`):\n\n```markdown\n+++\ntitle = \"My First Blog Post\"\ndate = 2021-08-08\n+++\n\nBla bla bla\n```\n\nThat works!\n\n## Deploy to Netlify\n\nWe'll want to put that wonder of a blog on Netlify. Everyone should be able to see it!\n\nI'll use [GitHub](https://github.com/sophiabrandt/zolablog) for source control and deployment.\n\n[Create a new repository](https://docs.github.com/en/get-started/quickstart/create-a-repo).\n\nFollow the instructions to add a new [remote](https://www.git-tower.com/learn/git/faq/git-add-remote/).\n\nWe also need a `.gitignore` file which will ignore the `public` folder. The `public` folder is where the finished (built) blog will live, we don't need it in source control.\n\n```bash\necho \"public\" > .gitignore\n```\n\nThen we'll add our work to the Git staging area and push it to GitHub:\n\n```bash\ngit add -A\ngit commit -m \"Initial commit\"\ngit push origin main\n```\n\nZola has a section in the [documentation that deals with Netlify](https://www.getzola.org/documentation/deployment/netlify/).\n\nWe'll need a `netlify.toml` file:\n```toml\n# You do need the `publish` and `command` variables.\n[build]\npublish = \"public\"\ncommand = \"zola build\"\n\n[build.environment]\n# Set the version name that you want to use and Netlify will automatically use it.\nZOLA_VERSION = \"0.14.0\"\n\n# The magic for deploying previews of branches.\n# We need to override the base url with whatever url Netlify assigns to our\n# preview site.  We do this using the Netlify environment variable\n# `$DEPLOY_PRIME_URL`.\n\n[context.deploy-preview]\ncommand = \"zola build --base-url $DEPLOY_PRIME_URL\"\n```\n\nIf you run `zola build` locally, the tool will create a `public` folder which contains the blog. That's why we are using `publish = \"public\"`.\n\nThe Zola documentation does not explain how to setup Netlify and how to connect your GitHub repository to Netlify.\n\nBut we can follow the [guide on the Hugo documentation which also comes with a few screenshots](https://gohugo.io/hosting-and-deployment/hosting-on-netlify/). Please ignore everything that's specific to Hugo.\n\nWhen you use the Netlify webpage to import your GitHub repository, Netlify will automatically read the necessary settings from `netlify.toml`. That means that you can keep to the default settings.\n\n[Here's the result of our walkthrough](https://zolablog.netlify.app/).\n\n## Thoughts\n\nThe documentation is pretty solid. If you've worked with static site generators before, the site explains what you need to know.\n\nFor total beginners, the documentation is too sparse. But newbies probably won't use Zola anyway as it's unlikely that a new programmer will learn Rust as a first language.\n\nI like the sensible templating language and structure of a Zola project. Some of the extra features (link checker, search index) are neat.\n\nAll in all, I can see Zola as an alternative to Hugo.\n\n## Links\n\n- [Static Site Generators][ssg]\n- [Jamstack List of Site Generators][jamstack]\n- [Top 3 Rust static site generators and when to use them][logrocket]\n- [Zola][zola]\n- [Feather theme for Zola][feather]\n\n[ssg]: https://staticsitegenerators.net/\n[jamstack]: https://jamstack.org/generators/\n[logrocket]: https://blog.logrocket.com/top-3-rust-static-site-generators-and-when-to-use-them/\n[zola]: https://www.getzola.org/\n[hugogitsubmodule]: https://discourse.gohugo.io/t/adding-a-theme-as-a-submodule-or-clone/8789\n[feather]: https://www.getzola.org/themes/feather/\n[netlify]: https://www.getzola.org/documentation/deployment/netlify/\n\n\n<hr />\n\nThank you for reading my blog.\n\nDon't hesitate to reach out via [email](mailto:hi@rockyourcode.com\") or [Twitter](https://twitter.com/hisophiabrandt)!\n"}